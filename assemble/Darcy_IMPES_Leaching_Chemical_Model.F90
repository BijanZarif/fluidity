!This file contains all the subroutines of leaching chemical model

#include "fdebug.h"

module darcy_impes_leaching_chemical_model

  use spud
  use fields
  use state_module
  use fldebug
  use field_options
  use spud
  use data_structures
  use initialise_fields_module
  use global_parameters, only: OPTION_PATH_LEN
  use darcy_impes_leaching_types
  use vtk_cache_module, only:vtk_cache_finalise
  use fefields, only: compute_cv_mass

  use darcy_impes_assemble_type, only: darcy_impes_type


  implicit none
  private
  
  public :: initialize_leaching_chemical_model, &
            finalize_leaching_chemical_model, &
            add_leach_chemical_prog_src_to_rhs, &
            calculate_leaching_chemical_model, &
            calculate_leach_heat_transfer_prog_Temperature_src_to_rhs, &
            calculate_leach_heat_transfer_src, &
            calculate_leach_rock_temperature, &
            add_leach_chemical_prog_src_linearization_to_lhs_rhs, &
            darcy_trans_heat_transfer_prog_src_linearization_to_lhs_rhs
  
       
  
  
  contains
  
  
  subroutine initialize_leaching_chemical_model(di)
     !!initialize the leaching chemical model
      
     type(darcy_impes_type), intent(inout) :: di
     
  
     !local parameter
     type(vector_field), pointer :: position =>null()
     integer :: p,f,flc, ns, nd, nb,fb, stat,ndata,nshape(2),n_md,f_md
     character(len=OPTION_PATH_LEN) :: option_path, reaction_name, path_l,path_md,md_name,name_temp
        !---------------------allocate the fields in the chemical model-------------
        !for the solution phase reactions
        if (have_option('/Leaching_chemical_model/SolutionPhaseReactions')) then           
           di%lc%have_sol=.true.
           !allocate the solution phase reaction
           ns= option_count('/Leaching_chemical_model/SolutionPhaseReactions/reaction')
           option_path=('/Leaching_chemical_model/SolutionPhaseReactions/reaction')
           do f= 1, ns
           
              call get_option(trim(option_path)//'['//int2str(f-1)//']/name', reaction_name)
              select case(trim(reaction_name)) 
                
                case("Ferrous_Oxidation")
                  di%lc%sol%feox%dcdt => extract_scalar_field(di%state(2), 'feox_dFe2_dt', stat=stat)
                  if (.not. stat==0) then
                    FLAbort('failed to extract the leaching reaction named feox_dFe2_dt')
                  end if

                  !get the reaction frefactor
                  di%lc%sol%feox%ak%A => extract_scalar_field(di%state(2), 'feox_prefactor', stat=stat)
                  if (.not. stat==0) then
                     FLAbort('failed to extract the leaching reaction named feox_prefactor')
                  end if

                  !get activation energy
                  path_l = trim(option_path)//'::'//trim(reaction_name)
                  call get_option(trim(path_l)//'/rate_constant_Arrhenius/activation_energy',& 
                                                                          di%lc%sol%feox%ak%ae) 
                  !get gas constant
                  call get_option(trim(path_l)//'/rate_constant_Arrhenius/gas_constant',& 
                                                                     di%lc%sol%feox%ak%gc)
                  !count the reacting bulk species
                  nb=option_count(trim(path_l)//'/bulk_fluid_conditions/bulk_concentration')
                  if (nb < 1)  FLAbort('the number of reacting bulk concentration for ferrous oxidation should be at least 1')
                  allocate(di%lc%sol%feox%ak%bulk(nb))
                  
                  do fb=1, nb
                    !get related bulk species name
                    call get_option(trim(path_l)//'/bulk_fluid_conditions/bulk_concentration['//int2str(fb-1)//']/name', di%lc%sol%feox%ak%bulk(fb)%lc_name)
                    !gri the order of reaction
                    call get_option(trim(path_l)//'/bulk_fluid_conditions/bulk_concentration::'//trim(di%lc%sol%feox%ak%bulk(fb)%lc_name)&
                                                                                          //'/order', di%lc%sol%feox%ak%bulk(fb)%order)
                    call get_option(trim(path_l)//'/bulk_fluid_conditions/bulk_concentration::'//trim(di%lc%sol%feox%ak%bulk(fb)%lc_name)&
                                                                                                              //'/phase', di%lc%sol%feox%ak%bulk(fb)%phase)
                  end do
                   
                  
                case('Jarosite_Precipitation')
                  di%lc%sol%jaro%dcdt => extract_scalar_field(di%state(2), 'Jarosite_dM_dt', stat=stat)
                  if (.not. stat==0) then
                    FLAbort('failed to extract the leaching reaction named Jarosite_dM_dt')
                  end if
                  di%lc%sol%jaro%js => extract_scalar_field(di%state(2), 'Jarosite_molar_concentration', stat=stat)
                  if (.not. stat==0) then
                    FLAbort('failed to extract the leaching reaction named Jarosite_molar_concentration')
                  end if
                  path_l = trim(option_path)//'::'//trim(reaction_name)
                  !get the name of the the scalar field used to calculate pH and Fe3 concentration
                  call get_option(trim(path_l)//'/H_name',di%lc%sol%jaro%H_name)
                  call get_option(trim(path_l)//'/Fe3_name',di%lc%sol%jaro%Fe3_name)



                case('Oxygen_dissolution')
                  di%lc%sol%oxdi%dcdt => extract_scalar_field(di%state(2), 'oxdi_dOg_dt', stat=stat)
                  if (.not. stat==0) then
                    FLAbort('failed to extract the leaching reaction named oxdi_dOg_dt')
                  end if
                  path_l = trim(option_path)//'::'//trim(reaction_name)
                  !get the name of the the scalar field used for gas phase oxygen and liquid phase oxygen
                  call get_option(trim(path_l)//'/og_name',di%lc%sol%oxdi%og_name)
                  call get_option(trim(path_l)//'/o2_name',di%lc%sol%oxdi%o2_name)

                case default
                  FLAbort("Leaching chemical algorithm " // trim(reaction_name) // " not found")
              end select
           
           end do
        
        else
           di%lc%have_sol=.false.

        end if
        
        !for mineral dissolution
        if (have_option('/Leaching_chemical_model/MineralDissolution')) then
           di%lc%have_dis=.true.
           !allocate the mineral dissolution
           nd=option_count('/Leaching_chemical_model/MineralDissolution/reaction')
           option_path=('/Leaching_chemical_model/MineralDissolution/reaction')
           do f=1, nd
             
              call get_option(trim(option_path)//'['//int2str(f-1)//']/name', reaction_name)
              select case(trim(reaction_name))
              
                case('CuFeS2_oxidation_aqueous_ferric_sulfate')
                  di%lc%dis%chal%dcdt => extract_scalar_field(di%state(2), 'chal_dCuFeS2_dt', stat=stat)
                  if (.not. stat==0) then
                    FLAbort('failed to extract the leaching reaction named chal_dCuFeS2_dt')
                  end if
                  !get extraction rate
                  di%lc%dis%chal%ex_r => extract_scalar_field(di%state(2), 'chal_extraction_rate', stat=stat)
                  if (.not. stat==0) then
                    FLAbort('failed to extract the leaching reaction named chal_extraction_rate')
                  end if
                  !get current extraction
                  di%lc%dis%chal%ex => extract_scalar_field(di%state(2), 'chal_current_extraction', stat=stat)
                  if (.not. stat==0) then
                    FLAbort('failed to extract the leaching reaction named chal_current_extraction')
                  end if
                  !get the molar concentraction of the mineral, mole per volume of heap
                  di%lc%dis%chal%mc => extract_scalar_field(di%state(2), 'chal_molar_concentration', stat=stat)
                  if (.not. stat==0) then
                    FLAbort('failed to extract the leaching reaction named chal_molar_concentration')
                  end if                 

                  !get the reaction frefactor
                  di%lc%dis%chal%ak%A => extract_scalar_field(di%state(2), 'chal_prefactor', stat=stat)
                  if (.not. stat==0) then
                     FLAbort('failed to extract the leaching reaction named chal_prefactor')
                  end if
 
                  !get activation energy
                  path_l = trim(option_path)//'::'//trim(reaction_name)
                  call get_option(trim(path_l)//'/rate_constant_Arrhenius/activation_energy',&         
                                                                          di%lc%dis%chal%ak%ae)
                  !get gas constant
                  call get_option(trim(path_l)//'/rate_constant_Arrhenius/gas_constant',&
                                                                     di%lc%dis%chal%ak%gc)
                  !count the reacting bulk species
                  nb=option_count(trim(path_l)//'/bulk_fluid_conditions/bulk_concentration')
                  if (nb < 1)  FLAbort('the number of reacting bulk concentration for chalcopyrite dissolution should be at least 1')
                  allocate(di%lc%dis%chal%ak%bulk(nb))
                  do fb=1, nb
                    !get related bulk species name
                    call get_option(trim(path_l)//'/bulk_fluid_conditions/bulk_concentration['//int2str(fb-1)//']/name', di%lc%dis%chal%ak%bulk(fb)%lc_name)
                    !gri the order of reaction
                    call get_option(trim(path_l)//'/bulk_fluid_conditions/bulk_concentration::'//trim(di%lc%dis%chal%ak%bulk(fb)%lc_name)&
                                                                                          //'/order', di%lc%dis%chal%ak%bulk(fb)%order)
                    call get_option(trim(path_l)//'/bulk_fluid_conditions/bulk_concentration::'//trim(di%lc%dis%chal%ak%bulk(fb)%lc_name)&
                                                                                                              //'/phase', di%lc%dis%chal%ak%bulk(fb)%phase)
                  end do

                  !------allocate and do cubic spline interpolation of the experiment data-----------------------
                  call get_option(trim(path_l)//'/experiment_data/number_of_data_points', di%lc%dis%chal%ndata)
                  ndata=di%lc%dis%chal%ndata
                  allocate(di%lc%dis%chal%spline_coe(4,ndata), di%lc%dis%chal%exp_ex(ndata), di%lc%dis%chal%exp_exrk(ndata))
                  
                  !get the size of the experiment data
                  nshape=option_shape(trim(path_l)//'/experiment_data/extraction')
                  if (nshape(1) /= ndata) then
                  !the size of the data points should be the same with the number of data points
                    FLExit('The dimension of experiment data points of extraction for chalcopyrite dissolution should be the same with number of&
                               data points used to do cubic spline interpolation')
                  end if
                  call get_option(trim(path_l)//'/experiment_data/extraction', di%lc%dis%chal%exp_ex)

                  nshape=option_shape(trim(path_l)//'/experiment_data/empirical_extraction_rate_over_k') 
                  if (nshape(1) /= ndata) then
                  !the size of the data points should be the same with the number of data points
                    FLExit('The dimension of experiment data points of empirical extraction rate over k for chalcopyrite dissolution 
                        &should be the same with number of data points used to do cubic spline interpolation')
                  end if
                  call get_option(trim(path_l)//'/experiment_data/empirical_extraction_rate_over_k',di%lc%dis%chal%exp_exrk)                  

                  !do cubic spline interpolation
                  call cubic_spline_coefficient(di%lc%dis%chal%exp_ex,di%lc%dis%chal%exp_exrk,di%lc%dis%chal%spline_coe)
                
                
                case('FeS2_oxidation_aqueous_ferric_sulfate')
                  di%lc%dis%pyri%dcdt => extract_scalar_field(di%state(2), 'pyri_dFeS2_dt', stat=stat)
                  if (.not. stat==0) then
                    FLAbort('failed to extract the leaching reaction named pyri_dFeS2_dt')
                  end if
                  !get extraction rate
                  di%lc%dis%pyri%ex_r => extract_scalar_field(di%state(2), 'pyri_extraction_rate', stat=stat)
                  if (.not. stat==0) then
                    FLAbort('failed to extract the leaching reaction named pyri_extraction_rate')
                  end if
                  !get current extraction
                  di%lc%dis%pyri%ex => extract_scalar_field(di%state(2), 'pyri_current_extraction', stat=stat)
                  if (.not. stat==0) then
                    FLAbort('failed to extract the leaching reaction named pyri_current_extraction')
                  end if
                  !get the molar concentraction of the mineral, mole per volume of heap
                  di%lc%dis%pyri%mc => extract_scalar_field(di%state(2), 'pyri_molar_concentration', stat=stat)
                  if (.not. stat==0) then
                    FLAbort('failed to extract the leaching reaction named pyri_molar_concentration')
                  end if

                 !get the reaction frefactor
                  di%lc%dis%pyri%ak%A => extract_scalar_field(di%state(2), 'pyri_prefactor', stat=stat)
                  if (.not. stat==0) then
                     FLAbort('failed to extract the leaching reaction named pyri_prefactor')
                  end if

                  !get activation energy
                  path_l = trim(option_path)//'::'//trim(reaction_name)
                  call get_option(trim(path_l)//'/rate_constant_Arrhenius/activation_energy',&
                                                                          di%lc%dis%pyri%ak%ae)
                  !get gas constant
                  call get_option(trim(path_l)//'/rate_constant_Arrhenius/gas_constant',&
                                                                     di%lc%dis%pyri%ak%gc)
                  !count the reacting bulk species
                  nb=option_count(trim(path_l)//'/bulk_fluid_conditions/bulk_concentration')
                  if (nb < 1)  FLAbort('the number of reacting bulk concentration for pyrite dissolution should be at least 1')
                  allocate(di%lc%dis%pyri%ak%bulk(nb))
                  do fb=1, nb
                    !get related bulk species name
                    call get_option(trim(path_l)//'/bulk_fluid_conditions/bulk_concentration['//int2str(fb-1)//']/name', di%lc%dis%pyri%ak%bulk(fb)%lc_name)
                    !gri the order of reaction
                    call get_option(trim(path_l)//'/bulk_fluid_conditions/bulk_concentration::'//trim(di%lc%dis%pyri%ak%bulk(fb)%lc_name)&
                                                                                          //'/order', di%lc%dis%pyri%ak%bulk(fb)%order)
                    call get_option(trim(path_l)//'/bulk_fluid_conditions/bulk_concentration::'//trim(di%lc%dis%pyri%ak%bulk(fb)%lc_name)&
                                                                                                              //'/phase', di%lc%dis%pyri%ak%bulk(fb)%phase)
                  end do
                  
                  !------allocate and do cubic spline interpolation of the experiment data-----------------------
                  call get_option(trim(path_l)//'/experiment_data/number_of_data_points', di%lc%dis%pyri%ndata)
                  ndata=di%lc%dis%pyri%ndata
                  allocate(di%lc%dis%pyri%spline_coe(4,ndata),di%lc%dis%pyri%exp_ex(ndata), di%lc%dis%pyri%exp_exrk(ndata))
    
                  !get the size of the experiment data
                  nshape=option_shape(trim(path_l)//'/experiment_data/extraction')
                  if (nshape(1) /= ndata) then
                  !the size of the data points should be the same with the number of data points
                    FLExit('The dimension of experiment data points of extraction for Pyrite dissolution should be the same with number of&
                               data points used to do cubic spline interpolation')
                  end if
                  call get_option(trim(path_l)//'/experiment_data/extraction',di%lc%dis%pyri%exp_ex)

                  nshape=option_shape(trim(path_l)//'/experiment_data/empirical_extraction_rate_over_k') 
                  if (nshape(1) /= ndata) then
                  !the size of the data points should be the same with the number of data points
                    FLExit('The dimension of experiment data points of empirical extraction rate over k for Pyrite dissolution&
                             should be the same with number of data points used to do cubic spline interpolation')
                  end if
                  call get_option(trim(path_l)//'/experiment_data/empirical_extraction_rate_over_k',di%lc%dis%pyri%exp_exrk)  
                  
                  !do cubic spline interpolation
                  call cubic_spline_coefficient(di%lc%dis%pyri%exp_ex,di%lc%dis%pyri%exp_exrk,di%lc%dis%pyri%spline_coe)

                
                case('S0_dissolution')
                  path_l = trim(option_path)//'::'//trim(reaction_name)
                  path_l = trim(option_path)//'::'//trim(reaction_name)
                  !get the name of the the scalar field used for H+ and liquid phase oxygen
                  call get_option(trim(path_l)//'/o2_name',di%lc%dis%sulf%o2_name)
                  call get_option(trim(path_l)//'/H_name',di%lc%dis%sulf%H_name)
                  !get the name of the the scalar field used to calculate pH and Fe3 concentration
                  call get_option(trim(path_l)//'/Dissolution_Algorithm/name',name_temp)
                  !wether the S0 is dissolved with bacteria or not
                  select case(trim(name_temp))
                    case('Non-bio_leaching')
                      di%lc%dis%sulf%bio = .false.
                      !get the percentage of S0 dissolution
                      call get_option(trim(path_l)//'/Dissolution_Algorithm'//'::'//trim(name_temp)//&
                      '/percentage_of_dissolve', di%lc%dis%sulf%ps)
                    case('bio_leaching')
                     di%lc%dis%sulf%bio = .true.
                     !not finish yet

                    case default
                      FLAbort("S0 dissolution algorithm" // trim(reaction_name) // " not found")
                  end select
                   
                  
                  di%lc%dis%sulf%S0 => extract_scalar_field(di%state(2), 'sulf_S0', stat=stat)
                  if (.not. stat==0) then
                    FLAbort('failed to extract the leaching reaction species named S0')
                  end if
                  di%lc%dis%sulf%dcdt => extract_scalar_field(di%state(2), 'sulf_dS0_dt', stat=stat)
                  if (.not. stat==0) then
                    FLAbort('failed to extract the leaching reaction named dS0_dt')
                  end if
                
                case default
                  FLAbort("Leaching chemical algorithm " // trim(reaction_name) // " not found")

             end select
             
           end do   
        else 
           di%lc%have_dis=.false.      

        end if

        !-------------allocate the temperature-----------------------
        !check the heat transfer model
        if (have_option('/Leaching_chemical_model/heat_transfer_model')) then
          option_path='/Leaching_chemical_model/heat_transfer_model'
          if (have_option(trim(option_path)//'/single_phase_heat_transfer')) then
             di%lc%ht%heat_transfer_single = .true.
             di%lc%ht%heat_transfer_two = .false.
             di%lc%ht%heat_transfer_three = .false.
          elseif (have_option(trim(option_path)//'/two_phases_heat_transfer')) then
             di%lc%ht%heat_transfer_two = .true.
             di%lc%ht%heat_transfer_single = .false.
             di%lc%ht%heat_transfer_three = .false.
          else
             di%lc%ht%heat_transfer_three = .true.
             di%lc%ht%heat_transfer_two = .false.
             di%lc%ht%heat_transfer_single = .false.
          end if

        else
         !default to calculate liquid phase heat transfer only
          di%lc%ht%heat_transfer_single = .true.
          di%lc%ht%heat_transfer_two = .false.
          di%lc%ht%heat_transfer_three = .false.
        end if

        di%lc%ht%liquid_temperature => extract_scalar_field(di%state(2), 'Temperature', stat=stat)
        if (.not. stat==0) then
           FLAbort('failed to extract the liquid temperature in phase 2 for leaching chemical model')
        end if
       
       if (.not. di%lc%ht%heat_transfer_single) then
       
           ! the rock temperature exist and extract it
           ! also initialize the rock temperature with the initial condition
           di%lc%ht%rock_temperature => extract_scalar_field(di%state(1), 'Rock_Temperature', stat=stat)
           if (.not. stat==0) then
              FLAbort('failed to extract the rock temperature in phase 1 for leaching chemical model')
           end if

           !initialize the rock temperature
           position => extract_vector_field(di%state(1), "Coordinate")
           call zero(di%lc%ht%rock_temperature)
           call initialise_field_over_regions(di%lc%ht%rock_temperature, &
                    trim(di%lc%ht%rock_temperature%option_path)//'/diagnostic/initial_condition', &
               position)

           call vtk_cache_finalise()

           nullify(position)

           !extract the source of rock temperature if exists
           if (have_option('/Leaching_chemical_model/heat_transfer_model/two_phases_heat_transfer/&
                    scalar_field::Rock_Temperature/scalar_field::Rock_Temperature_Source')) then
             
             di%lc%ht%have_rock_temperature_src = .true.
             
             di%lc%ht%rock_temperature_src => extract_scalar_field(di%state(1), 'Rock_Temperature_Source', stat=stat)

             if (.not. stat==0) then
               FLAbort('failed to extract the rock temperature source in phase 1 for leaching chemical model')
             end if
           end if         


           !extract the rock density and heat capacity
           di%lc%ht%rock_cp => extract_scalar_field(di%state(1), 'Rock_Cp', stat=stat)
           if (.not. stat==0) then
             FLAbort('failed to extract the Rock heat capacity for leaching chemical model')
           end if
           di%lc%ht%rock_density => extract_scalar_field(di%state(1), 'Rock_density', stat=stat)
           if (.not. stat==0) then
             FLAbort('failed to extract the Rock density for leaching chemical model')
           end if
        end if   

        if (di%lc%ht%heat_transfer_two) then
           !extract the rock-liquid effective heat transfer coefficient
           di%lc%ht%K_eff_ls => extract_scalar_field(di%state(1), 'K_eff_sl', stat=stat)
           if (.not. stat==0) then
             FLAbort('failed to extract rock-liquid effective heat transfer coefficient')
           end if

           !extract the rock heat transfer source
           ns= option_count(trim(option_path)//'/two_phases_heat_transfer/heat_transfer_sources/scalar_field')
           if (ns==0) FLAbort('For multiple phases heat transfer, please turn on the source term of the rock phase temperature')
           path_l= trim(option_path)//'/two_phases_heat_transfer/heat_transfer_sources/scalar_field'
           allocate(di%lc%ht%two_phase_src_solid(ns))
           do f= 1, ns
              call get_option(trim(path_l)//'['//int2str(f-1)//']/name', reaction_name)
              select case(trim(reaction_name))

                case('solid_liquid_heat_transfer_rock_phase') 

                   di%lc%ht%two_phase_src_solid(f)%ptr => extract_scalar_field(di%state(1), 'solid_liquid_heat_transfer_rock_phase', stat=stat)
                   if (.not. stat==0) then
                      FLAbort('failed to extract solid_liquid_heat_transfer_rock_phase under phase 1')
                   end if

                case('mineral_dissolution_heat_sources')
                    di%lc%ht%two_phase_src_solid(f)%ptr => extract_scalar_field(di%state(1), 'mineral_dissolution_heat_sources', stat=stat)
                    if (.not. stat==0) then
                      FLAbort('failed to extract mineral_dissolution_heat_sources under phase 1')
                    end if

                    !count the number of mineral dissolution sources
                    n_md=option_count(trim(path_l)//'::mineral_dissolution_heat_sources/mineral_dissolutions')
                    path_md=trim(path_l)//'::mineral_dissolution_heat_sources/mineral_dissolutions'
                    allocate(di%lc%ht%rock_md_src(n_md))
                    do f_md=1,n_md
                      call get_option(trim(path_md)//'['//int2str(f_md-1)//']/name',md_name)
                      di%lc%ht%rock_md_src(f_md)%md_src => extract_scalar_field(di%state(1), md_name, stat=stat)
                      if (.not. stat==0) then
                        FLAbort('failed to extract field '//md_name//' under phase 1')
                      end if
                      call get_option(trim(path_md)//'::'//trim(md_name)//'/Enthalpy', di%lc%ht%rock_md_src(f_md)%Enthalpy)                      
                    end do

                case default
                   FLAbort("Heat transfer algorithm " // trim(reaction_name) // "under rock temperature not found")

              end select
           end do
           
           !******************initialize the leaching heat transfer source term under liquid temperature
           if (.not. have_option('/material_phase::Phase2/scalar_field::Temperature/prognostic/leaching_temperature_sources')) then
              FLAbort("please turn on the liquid temperature and its leaching temperature sources terms for two phase heat transfer")
           end if
           
           path_l='/material_phase::Phase2/scalar_field::Temperature/prognostic/leaching_temperature_sources/heat_transfer_sources/scalar_field'
           di%lc%ht%liquid_cp => extract_scalar_field(di%state(2), 'Liquid_Cp',stat=stat)
           if (.not. stat==0) then
              FLAbort('failed to extract liquid heat capacity under phase 2')
           end if

           !extract the heat transfer sources
           ns=option_count(trim(path_l))
           if (ns==0) FLAbort('For multiple phases heat transfer, please turn on the source term of liquid phase temperature')
           allocate(di%lc%ht%two_phase_src_liquid(ns)) 
           do f= 1, ns
             call get_option(trim(path_l)//'['//int2str(f-1)//']/name', reaction_name)
             select case(trim(reaction_name))
                case('solid_liquid_heat_transfer_liquid_phase')
                  di%lc%ht%two_phase_src_liquid(f)%ptr => extract_scalar_field(di%state(2), 'solid_liquid_heat_transfer_liquid_phase', stat=stat)
                  if (.not. stat==0) then
                    FLAbort('failed to extract solid_liquid_heat_transfer_liquid_phase under phase 2')
                  end if

                case('solution_phase_heat_sources')
                  di%lc%ht%two_phase_src_liquid(f)%ptr => extract_scalar_field(di%state(2), 'solution_phase_heat_sources', stat=stat)
                  if (.not. stat==0) then
                    FLAbort('failed to extract solution_phase_heat_sources under phase 2')
                  end if

                  !count the number of solution_phase_heat_sources
                  n_md=option_count(trim(path_l)//'::solution_phase_heat_sources/solution_phase_reactions')
                  path_md=trim(path_l)//'::solution_phase_heat_sources/solution_phase_reactions'
                  allocate(di%lc%ht%liquid_sr_src(n_md))
                  do f_md=1,n_md
                    call get_option(trim(path_md)//'['//int2str(f_md-1)//']/name',md_name)
                    di%lc%ht%liquid_sr_src(f_md)%sr_src => extract_scalar_field(di%state(1), md_name, stat=stat)
                    if (.not. stat==0) then
                       FLAbort('failed to extract field'//md_name// 'under phase 1')
                    end if
                    call get_option(trim(path_md)//'::'//trim(md_name)//'/Enthalpy', di%lc%ht%liquid_sr_src(f_md)%Enthalpy)
                  end do

                  case default
                    FLAbort("Heat transfer algorithm " // trim(reaction_name) // "under rock temperature not found")
             end select
           end do

        end if

        if (di%lc%ht%heat_transfer_three) then
          !the three phase heat transfer between air, .iquid and rock
          di%lc%ht%air_temperature => extract_scalar_field(di%state(1), 'Temperature', stat=stat)
          if (.not. stat==0) then
             FLAbort('failed to extract the air temperature in heat transfer model for leaching chemical model')
          end if
        end if

        !----------allocate the generic prognostic leaching source terms-------------       
        !--loop over phase
        do f=1, size(di%generic_prog_sfield)
          option_path=di%generic_prog_sfield(f)%sfield%option_path
          p=di%generic_prog_sfield(f)%phase
          !---check for heat transfer source under temperature field
          !check the source linearization
          if (have_option(trim(option_path)//'/prognostic/leaching_temperature_sources/Source_Linearization')) then
             di%generic_prog_sfield(f)%lh_src%src_linear%have=.true.
          else
             di%generic_prog_sfield(f)%lh_src%src_linear%have=.false.
          end if

          if (have_option(trim(option_path)//'/prognostic/LeachingChemicalSourceTerm/Source_Linearization')) then
            di%generic_prog_sfield(f)%lc_src%src_linear%have=.true.
          else
            di%generic_prog_sfield(f)%lc_src%src_linear%have=.false.
          end if

          !---check for heat transfer source under temperature field
          ns=option_count(trim(option_path)//'/prognostic/leaching_temperature_sources/heat_transfer_sources/scalar_field')
          if (.not. ns==0) then
            if (di%lc%ht%heat_transfer_single) then
              FLAbort('Cannot use the single heat transfer model to calculate the solid-liquid heat transfer term under the temperature of phase'// int2str(f) )
            end if
      
            di%generic_prog_sfield(f)%lh_src%have_heat_src=.true.
          else
            di%generic_prog_sfield(f)%lh_src%have_heat_src=.false.
          end if
          !---check for solution phase source-----------
          ns = option_count(trim(option_path)//'/prognostic/LeachingChemicalSourceTerm/SolutionPhaseSource/scalar_field')
          if (.not. ns==0) then
            di%generic_prog_sfield(f)%lc_src%have_sol_src = .true.
            allocate(di%generic_prog_sfield(f)%lc_src%sfield_sol_src(ns))

            !extract the name of the chemical reaction and stoichemistry factor
            do flc=1, ns 
              call get_option(trim(option_path)//'/prognostic/LeachingChemicalSourceTerm/&
                              SolutionPhaseSource/scalar_field['//int2str(flc-1)//']/name', & 
                              di%generic_prog_sfield(f)%lc_src%sfield_sol_src(flc)%lc_name)
              
              call get_option(trim(option_path)//'/prognostic/LeachingChemicalSourceTerm/&
                              SolutionPhaseSource/scalar_field['//int2str(flc-1)//']/&
                              diagnostic/stoichiometric_factor', &
                              di%generic_prog_sfield(f)%lc_src%sfield_sol_src(flc)%sto_factor)
              di%generic_prog_sfield(f)%lc_src%sfield_sol_src(flc)%sfield => extract_scalar_field(di%state(p), &
                                                               trim(di%generic_prog_sfield(f)%sfield%name)//'_'&
                                           //trim(di%generic_prog_sfield(f)%lc_src%sfield_sol_src(flc)%lc_name))
            end do
     
          else
            di%generic_prog_sfield(f)%lc_src%have_sol_src = .false.

          end if
          
          !-----check for mineral dissolution phase source------
          nd = option_count(trim(option_path)//'/prognostic/LeachingChemicalSourceTerm/MineralDissolutionSource/scalar_field')
          if (.not. nd==0) then
            di%generic_prog_sfield(f)%lc_src%have_dis_src = .true.
            allocate(di%generic_prog_sfield(f)%lc_src%sfield_dis_src(nd))

            !extract the name of the chemical reaction and stoichemistry factori
            do flc=1, nd
              call get_option(trim(option_path)//'/prognostic/LeachingChemicalSourceTerm/&
                              MineralDissolutionSource/scalar_field['//int2str(flc-1)//']/name', &
                              di%generic_prog_sfield(f)%lc_src%sfield_dis_src(flc)%lc_name)

              call get_option(trim(option_path)//'/prognostic/LeachingChemicalSourceTerm/&
                              MineralDissolutionSource/scalar_field['//int2str(flc-1)//']/&
                              diagnostic/stoichiometric_factor', &
                              di%generic_prog_sfield(f)%lc_src%sfield_dis_src(flc)%sto_factor)
              di%generic_prog_sfield(f)%lc_src%sfield_dis_src(flc)%sfield => extract_scalar_field(di%state(p), &
                                                               trim(di%generic_prog_sfield(f)%sfield%name)//"_"&
                                           //trim(di%generic_prog_sfield(f)%lc_src%sfield_dis_src(flc)%lc_name))
            end do


          else
            di%generic_prog_sfield(f)%lc_src%have_dis_src = .false.
          
          endif

        end do

  end subroutine initialize_leaching_chemical_model

  !--------------------------------------------------------------------------------------------------------
  subroutine finalize_leaching_chemical_model(di) 
     
     !finalize terms from leaching_chemical_model

     type(darcy_impes_type), intent(inout) :: di
     
     !local variables
     integer :: f, ns, nd, flc
     
     character(len=OPTION_PATH_LEN) :: option_path, reaction_name
     
     di%lc%have_leach_chem_model= .False.
     
     !deallocate leaching chemical model
     if (di%lc%have_sol) then
       
       di%lc%have_sol=.false.
       ns= option_count('/Leaching_chemical_model/SolutionPhaseReactions/reaction')
       option_path=('/Leaching_chemical_model/SolutionPhaseReactions/reaction')
       do f= 1, ns

         call get_option(trim(option_path)//'['//int2str(f-1)//']/name', reaction_name)
         select case(trim(reaction_name))

           case("Ferrous_Oxidation")
              nullify(di%lc%sol%feox%dcdt)
              nullify(di%lc%sol%feox%ak%A)
              deallocate(di%lc%sol%feox%ak%bulk)

           case('Jarosite_Precipitation')
              nullify(di%lc%sol%jaro%dcdt)

           case('Oxygen_dissolution')
              nullify(di%lc%sol%oxdi%dcdt)
         end select
         
       end do

     end if
     
     
     if (di%lc%have_dis) then
       
       di%lc%have_dis=.false.
       nd=option_count('/Leaching_chemical_model/MineralDissolution/reaction')
       option_path=('/Leaching_chemical_model/MineralDissolution/reaction')
       do f= 1, nd

         call get_option(trim(option_path)//'['//int2str(f-1)//']/name', reaction_name)
         select case(trim(reaction_name))

           case('CuFeS2_oxidation_aqueous_ferric_sulfate')
              nullify(di%lc%dis%chal%dcdt)
              nullify(di%lc%dis%chal%ex_r)
              nullify(di%lc%dis%chal%ex)
              nullify(di%lc%dis%chal%mc)
              nullify(di%lc%dis%chal%ak%A)
              deallocate(di%lc%dis%chal%ak%bulk)
              deallocate(di%lc%dis%chal%spline_coe)
              deallocate(di%lc%dis%chal%exp_ex)
              deallocate(di%lc%dis%chal%exp_exrk)
              
           case('FeS2_oxidation_aqueous_ferric_sulfate')
              nullify(di%lc%dis%pyri%dcdt)
              nullify(di%lc%dis%pyri%ex_r)
              nullify(di%lc%dis%pyri%ex)
              nullify(di%lc%dis%pyri%mc)
              nullify(di%lc%dis%pyri%ak%A)
              deallocate(di%lc%dis%pyri%ak%bulk)
              deallocate(di%lc%dis%pyri%spline_coe)
              deallocate(di%lc%dis%pyri%exp_ex)
              deallocate(di%lc%dis%pyri%exp_exrk)

           case('S0_dissolution')
              nullify(di%lc%dis%sulf%S0)
              nullify(di%lc%dis%sulf%dcdt)
              di%lc%dis%sulf%bio = .false.
         end select
           
       end do

     end if

     !deallocate leaching prognostic source field 
     do f=1, size(di%generic_prog_sfield)
       di%generic_prog_sfield(f)%lh_src%src_linear%have=.false.
       di%generic_prog_sfield(f)%lc_src%src_linear%have=.false.
       if (di%generic_prog_sfield(f)%lh_src%have_heat_src) &
         di%generic_prog_sfield(f)%lh_src%have_heat_src=.false.

       if (di%generic_prog_sfield(f)%lc_src%have_sol_src) then
         di%generic_prog_sfield(f)%lc_src%have_sol_src = .false.
         do flc=1, size(di%generic_prog_sfield(f)%lc_src%sfield_sol_src)
           nullify(di%generic_prog_sfield(f)%lc_src%sfield_sol_src(flc)%sfield)
         end do
         deallocate(di%generic_prog_sfield(f)%lc_src%sfield_sol_src)
       end if
       
       if (di%generic_prog_sfield(f)%lc_src%have_dis_src) then
         di%generic_prog_sfield(f)%lc_src%have_dis_src = .false.
         do flc=1, size(di%generic_prog_sfield(f)%lc_src%sfield_dis_src)
           nullify(di%generic_prog_sfield(f)%lc_src%sfield_dis_src(flc)%sfield)
         end do
         deallocate(di%generic_prog_sfield(f)%lc_src%sfield_dis_src)
       end if

     end do
   
     !deallocate heat transfer model
     if (have_option('/Leaching_chemical_model/heat_transfer_model')) then
       nullify(di%lc%ht%liquid_temperature)
       if (.not. di%lc%ht%heat_transfer_single) then
          nullify(di%lc%ht%rock_temperature)
          nullify(di%lc%ht%rock_cp)
          nullify(di%lc%ht%rock_density)

          if (di%lc%ht%heat_transfer_two) then
             !for rock phase
             nullify(di%lc%ht%K_eff_ls)
             do flc=1,size(di%lc%ht%two_phase_src_solid)
               nullify(di%lc%ht%two_phase_src_solid(flc)%ptr)
             end do
             deallocate(di%lc%ht%two_phase_src_solid)
             
             if (allocated(di%lc%ht%rock_md_src)) then
               do flc=1,size(di%lc%ht%rock_md_src)
                 nullify(di%lc%ht%rock_md_src(flc)%md_src)
               end do
               deallocate(di%lc%ht%rock_md_src)
             end if

             !for liquid phase
             nullify(di%lc%ht%liquid_cp)
             do flc=1,size(di%lc%ht%two_phase_src_liquid)
               nullify(di%lc%ht%two_phase_src_liquid(flc)%ptr)
             end do
             deallocate(di%lc%ht%two_phase_src_liquid)

             if (allocated(di%lc%ht%liquid_sr_src)) then
               do flc=1,size(di%lc%ht%liquid_sr_src)
                 nullify(di%lc%ht%liquid_sr_src(flc)%sr_src)
               end do
               deallocate(di%lc%ht%liquid_sr_src)
             end if  
          end if

          if (di%lc%ht%heat_transfer_three) then
            nullify(di%lc%ht%rock_temperature)
            nullify(di%lc%ht%air_temperature)
          end if    
       end if

       di%lc%ht%heat_transfer_single = .false.
       di%lc%ht%heat_transfer_two = .false.
       di%lc%ht%heat_transfer_three = .false.
 
     end if

   end subroutine finalize_leaching_chemical_model


   !********The following are the subroutines to calculate fields for the chemical model****************
   
   !-------------Add the chemical source terms to RHS for solving the prognostic fields----------------
   subroutine add_leach_chemical_prog_src_to_rhs(di,f)
      type(darcy_impes_type), intent(inout) :: di
      integer, intent(in) :: f
      
      !local variables
      type(scalar_field) :: leach_src, single_src
      integer :: n,p,i
      real :: s_factor !the stoichemistry factor
      character(len=FIELD_NAME_LEN) :: lc_name
      type(scalar_field), pointer :: src => null()
      
      call allocate(leach_src,di%pressure_mesh)
      call zero(leach_src)
      
      call allocate(single_src,di%pressure_mesh)

      !for the solution phase reactions
      if (di%generic_prog_sfield(f)%lc_src%have_sol_src) then

        do n=1, size(di%generic_prog_sfield(f)%lc_src%sfield_sol_src) 
          lc_name = di%generic_prog_sfield(f)%lc_src%sfield_sol_src(n)%lc_name
          s_factor = di%generic_prog_sfield(f)%lc_src%sfield_sol_src(n)%sto_factor
          call zero(single_src)
          
          select case(trim(lc_name))
             case("Ferrous_Oxidation")
               if (.not. associated(di%lc%sol%feox%dcdt)) &
               FLAbort('Ferrous_Oxidation is turned off in the leaching chemical model, while its source term is turned on under the prognostic scaler field') 
               src => di%lc%sol%feox%dcdt             
             
             case('Jarosite_Precipitation')
               if (.not. associated(di%lc%sol%jaro%dcdt)) &
               FLAbort('Jarosite_Precipitation is turned off in the leaching chemical model, while its source term is turned on under the prognostic scaler field')  
               src => di%lc%sol%jaro%dcdt
            
             case('Oxygen_dissolution_liquid_phase') 
               if (.not. associated(di%lc%sol%oxdi%dcdt)) &
               FLAbort('Oxygen_dissolution is turned off in the leaching chemical model, while its source term is turned on under the prognostic scaler field')
               cycle !calculate elsewhere, in the calculate oxygen dissolution subroutine
            
             case('Oxygen_dissolution_gas_phase')
               if (.not. associated(di%lc%sol%oxdi%dcdt)) &
               FLAbort('Oxygen_dissolution is turned off in the leaching chemical model, while its source term is turned on under the prognostic scaler field')
               cycle !calculate elsewhere, in the calculate oxygen dissolution subroutine
            
             case default
               FLAbort("Leaching chemical algorithm " // trim(lc_name) // " not found")
          end select
          
          call addto(single_src,src,s_factor)
          call addto(leach_src, single_src) !addto the chemical source term with scale of the stoichemistry factor
          
          p=di%generic_prog_sfield(f)%phase
          
           
          node_loop: do i=1,di%number_pmesh_node

            single_src%val(i)=single_src%val(i)/(di%porosity_pmesh%val(i)*di%saturation(p)%ptr%val(i))

            di%generic_prog_sfield(f)%lc_src%sfield_sol_src(n)%sfield%val(i)=single_src%val(i) !mole/m^3_solution               
          end do node_loop
          
        end do

      end if

      !for the mineral dissolution ractions
      if (di%generic_prog_sfield(f)%lc_src%have_dis_src) then
         
        do n=1, size(di%generic_prog_sfield(f)%lc_src%sfield_dis_src)
          lc_name = di%generic_prog_sfield(f)%lc_src%sfield_dis_src(n)%lc_name
          s_factor = di%generic_prog_sfield(f)%lc_src%sfield_dis_src(n)%sto_factor
          call zero(single_src)
          
          select case(trim(lc_name))
             case("CuFeS2_oxidation_aqueous_ferric_sulfate")
               if (.not. associated(di%lc%dis%chal%dcdt)) &
               FLAbort('CuFeS2_oxidation_aqueous_ferric_sulfate is turned off in the leaching chemical model,while its source term is turned on under the prognostic scaler field')
               src => di%lc%dis%chal%dcdt

             case('FeS2_oxidation_aqueous_ferric_sulfate')
               if (.not. associated(di%lc%dis%pyri%dcdt)) &
               FLAbort('FeS2_oxidation_aqueous_ferric_sulfate is turned off in the leaching chemical model, while its source term is turned on under the prognostic scaler field')
               src => di%lc%dis%pyri%dcdt 

             case('S0_dissolution')
               if (.not. associated(di%lc%dis%sulf%dcdt)) &
               FLAbort('S0_dissolution is turned off in the leaching chemical model,while its source term is turned on under the prognostic scaler field')
               src => di%lc%dis%sulf%dcdt

             case default
               FLAbort("Leaching chemical algorithm " // trim(lc_name) // " not found")
          end select
          
          call addto(single_src,src,s_factor)
          call addto(leach_src, single_src) !addto the chemical source term with scale of the stoichemistry factor
          call set(di%generic_prog_sfield(f)%lc_src%sfield_dis_src(n)%sfield, single_src)
          
        end do
        
      end if
      
      !Add leaching chemical source term to rhs
      call compute_cv_mass(di%positions, di%cv_mass_pressure_mesh_with_source, leach_src)
      call addto(di%rhs, di%cv_mass_pressure_mesh_with_source)

      call deallocate(leach_src)
      call deallocate(single_src)

      nullify(src)
   end subroutine add_leach_chemical_prog_src_to_rhs
   

   !-------------calculate leaching chemical model----------------------------------------------!
   subroutine calculate_leaching_chemical_model(di)
      type(darcy_impes_type), intent(inout) :: di
      
      integer :: i
      real :: T,ft, dt
      real, dimension(:), allocatable :: A !pre-factor of the arrhenius rate constant
      type(scalar_field), pointer :: rock_temperature
      !for mineral dissolution
      if (di%lc%have_dis) then  
         if (.not. di%lc%ht%heat_transfer_single) then
           rock_temperature =>di%lc%ht%rock_temperature
         else
           rock_temperature =>di%lc%ht%liquid_temperature
         end if
         ! Chalcopyrite oxidation 
         if (di%lcsub%have_leach_subcycle) then
           dt=di%lcsub%sub_dt
         else
           dt=di%dt
         end if
         if (associated(di%lc%dis%chal%dcdt)) call calculate_mineral_dissolution_semi_empirical_model(di%state,&
                                          rock_temperature,di%number_pmesh_node,dt,di%lc%dis%chal,&
                                          di%saturation(2)%ptr)
         !pyrite dissolution
         if (associated(di%lc%dis%pyri%dcdt)) call calculate_mineral_dissolution_semi_empirical_model(di%state,&
                                          rock_temperature,di%number_pmesh_node,dt,di%lc%dis%pyri,&
                                          di%saturation(2)%ptr)
         !S0 dissolution
         if (associated(di%lc%dis%sulf%dcdt)) call calculate_S0_dissolution(di)
         !finalize                                 
         nullify(rock_temperature)                                 
      end if
  
      if (di%lc%have_sol) then
         !ferrous oxidation
         if (associated(di%lc%sol%feox%dcdt)) then
            !calcultae the prefactor A, since the partial pressure of oxygen in the reaction rate equation are
            !transformed to the molar concentraction of dissolved oxygen by empirical equilibrium equatiion (Tromans1998)
            allocate(A(di%number_pmesh_node))
            
            node_loop: do i=1,di%number_pmesh_node
               !reaction only start when liquid saturation is not zero
               if (di%saturation(2)%ptr%val(i)>=1.0e-4) then
                 !calculate the equilibrium constant ft, o2=og*ft
                 T=di%lc%ht%liquid_temperature%val(i)
                 ft=(0.046*(T**2.0)+203.35*T*DLOG(T/298.0)-(299.378+0.092*T)*(T-298)-20.591*(10.0**3.0))/(T*8.3144)
                 ft=EXP(ft)
                 A(i)=di%lc%sol%feox%ak%A%val(i)/ft
               else
                 A(i)=0.0
               end if
            end do node_loop
            
            call calculate_solution_phase_arrhenius_type_reaction_rate(di%state,&
                 A,di%lc%ht%liquid_temperature,di%number_pmesh_node,di%lc%sol%feox) 
            !change the mole/(m^3 solution)/s to mole/(m^3 heap)/s
       
            call scale(di%lc%sol%feox%dcdt,di%porosity_pmesh)
            
            call scale(di%lc%sol%feox%dcdt,di%saturation(2)%ptr)

            deallocate(A)

         endif

         !jarosite oxidation
         if (associated(di%lc%sol%jaro%dcdt)) then
           call calculate_jarosite_precipitation(di) 
         end if

         !oxygen dissolution
         if (associated(di%lc%sol%oxdi%dcdt)) then
           call calculate_oxygen_dissolution(di)
         end if
         
      end if
     
      contains 

        subroutine calculate_mineral_dissolution_semi_empirical_model(states,temperature,node_number,dt,mineral,sat)
              type(leaching_semi_empirical_model_type), intent(inout) :: mineral
              type(state_type),dimension(:), intent(in) :: states
              integer, intent(in) :: node_number
              type(scalar_field), intent(in) :: temperature
              type(scalar_field), intent(in) :: sat !liquid saturation
              real, intent(in) :: dt !the time step
              real :: cb_n,mc, k_rate, ext, ext_rk, ext_r, dcdt !bode value of bulk concentration, molar concentration of the mineral, 
                                                    !tate constant,current extraction,the extraction rate with k, the extraction rate, the concentration change rate
              type(scalar_field_pointer), dimension(:), allocatable :: cb !the reacting bulk species
              real, dimension(:),allocatable ::  m ! the single node val of reacting bulk species and order of reaction
              real, dimension(:), pointer :: a,b,c,d !spline coefficienti
              real, dimension(4) :: a_c !the constants used to calculate arrhenius reattion rate
                                        !pre-factor,activation energy,gas constant,temperature
              character(len=FIELD_NAME_LEN) :: cb_name !the name of the reacting species
              integer :: p, nspecies, isp, node, stat
             
              !get the number of species which take part in reaction
              nspecies = size(mineral%ak%bulk)             
              allocate(cb(nspecies), m(nspecies))
              
              !spline coefficient
              a => mineral%spline_coe(1,:)
              b => mineral%spline_coe(2,:)
              c => mineral%spline_coe(3,:)
              d => mineral%spline_coe(4,:)

              do isp = 1, nspecies
                m(isp) = mineral%ak%bulk(isp)%order
                cb_name = mineral%ak%bulk(isp)%lc_name
                p = mineral%ak%bulk(isp)%phase
                cb(isp)%ptr => extract_scalar_field(states(p), trim(cb_name), stat)
                if (.not. stat==0) then
                  FLAbort('failed to extract the reacting species')
                end if
              end do
              
              !Calculate exctraction rate, extraction, and concentration change rate for each node
              !node loop
              node_loop: do node=1, node_number
                   !the current extraction of the element node
                   ext = node_val(mineral%ex,node)
                
                   if (sat%val(node)<=1.0e-8) then
                     call set(mineral%ex_r, node, 0.0)
                     call set(mineral%ex, node, ext)
                     call set(mineral%dcdt, node, 0.0)
                     cycle
                   end if

                   !the pre_factor is ingnored in the semi-imperical model, set to 1.0
                   a_c(1)=node_val(mineral%ak%A, node)
                   !the activation energy
                   a_c(2)=mineral%ak%ae
                   !the gas constant
                   a_c(3)=mineral%ak%gc
                   !the reaction temperature is based on the liquid temperature
                   a_c(4)=node_val(temperature, node)

                   !the molar concentration of the mineral at the unit of mole per volumn of heap
                   mc= node_val(mineral%mc, node)

                   !if extraction of the mineral is nearly one, not reacted
                   if ((1.0-ext)<=1.0D-15) then
                      k_rate=0.0  !stop reaction
                      go to 1
                   end if
                   
                   call calculate_arrhenius_reaction_rate_constant(nspecies,node,cb,m,a_c,k_rate)
                   
                 1 if (k_rate==0.0) then
                       call set(mineral%ex_r, node, 0.0)
                       call set(mineral%ex, node, ext)
                       call set(mineral%dcdt, node, 0.0)
                   else                           
                       !do cubic spline interpolation for current extraction rate with k
                       call cubic_spline_interpolation(a,b,c,d,mineral%exp_ex,ext,ext_rk) 
                       ext_r = ext_rk * k_rate
                   
                       !update the new extraction rate, unit is extraction per day
                       call set(mineral%ex_r, node, ext_r)
                   
                       !update the new extraction of the node
                       ext=ext+(ext_r/86400.0)*dt
                       call set(mineral%ex, node, ext)

                       !calculate the concentration change rate of the mineral
                       !the molar concentration %mc is at the unit of mole/m^3_heap
                       !the concentration change rate is at the unit of mole/m^3_heap/s
                       dcdt= -(ext_r/86400.0)*mc
                       call set(mineral%dcdt, node, dcdt)
                   end if 
                    
              end do node_loop

              !finalize
              !nullify before deallocate
              nullify(a,b,c,d)
              do isp = 1, nspecies
                nullify(cb(isp)%ptr)
              end do

              deallocate(cb)
              deallocate(m)
          
        end subroutine calculate_mineral_dissolution_semi_empirical_model

        subroutine calculate_solution_phase_arrhenius_type_reaction_rate(states,A,temperature,node_number,reaction)
              type(leaching_arrhenius_reaction_type), intent(inout) :: reaction
              type(state_type),dimension(:), intent(in) :: states
              integer, intent(in) :: node_number
              real, dimension(:),intent(in) :: A !pre-factor of the arrhenius rate constant
              type(scalar_field), intent(in) :: temperature

              real, dimension(4) :: a_c !the constants used to calculate arrhenius reattion rate
                                        !pre-factor,activation energy,gas constant,temperature
              character(len=FIELD_NAME_LEN) :: cb_name !the name of the reacting species
              type(scalar_field_pointer), dimension(:), allocatable :: cb !the reacting bulk species
              real, dimension(:),allocatable ::  m ! the single node val of reacting bulk species and order of reaction
              real :: k_rate
              
              integer :: p, nspecies, isp, node, stat

              !get the number of species which take part in reaction
              nspecies = size(reaction%ak%bulk)
              allocate(cb(nspecies), m(nspecies))
              
              do isp = 1, nspecies
                m(isp) = reaction%ak%bulk(isp)%order
                cb_name = reaction%ak%bulk(isp)%lc_name
                p = reaction%ak%bulk(isp)%phase
                cb(isp)%ptr => extract_scalar_field(states(p), trim(cb_name), stat)
                if (.not. stat==0) then
                  FLAbort('failed to extract the reacting species')
                end if
              end do

              !Calculate exctraction rate, extraction, and concentration change rate for each node
              !node loop
              node_loop: do node=1, node_number
                   
                   if (abs(A(node))<=1.0e-16) then
                     call set(reaction%dcdt, node, 0.0)
                   else
                     !the pre_factor is ingnored in the semi-imperical model, set to 1.0
                     a_c(1)=A(node)
                     !the activation energy
                     a_c(2)=reaction%ak%ae
                     !the gas constant
                     a_c(3)=reaction%ak%gc
                     !the reaction temperature is based on the liquid temperature
                     a_c(4)=node_val(temperature, node)
                     
                     call calculate_arrhenius_reaction_rate_constant(nspecies,node,cb,m,a_c,k_rate)

                     !mole per volumn of solution per second
                     call set(reaction%dcdt, node, k_rate)
                   end if
              end do node_loop

              !finalize
              do isp = 1, nspecies
               nullify(cb(isp)%ptr)
              end do

              deallocate(cb)
              deallocate(m)
 
        end subroutine calculate_solution_phase_arrhenius_type_reaction_rate

        subroutine calculate_arrhenius_reaction_rate_constant(nspecies,node,cb,m,ac,k_rate)
           integer, intent(in) :: nspecies, node
           type(scalar_field_pointer), dimension(:), intent(in) :: cb !the reacting bulk species
           real, dimension(4), intent(in) :: ac 
           real, dimension(:),intent(in) :: m 
           real, intent(inout) :: k_rate
           
           integer :: isp
           real ::cb_n
           
           !calculate rate constant, which is k=A*e^(Ea/(R*T))*(ab1**m1)*(ab2**m2)....
           k_rate=ac(1)*(EXP(ac(2)/(ac(3)*ac(4))))
           do isp= 1, nspecies                 
              cb_n = node_val(cb(isp)%ptr, node)
              if (cb_n <=0.1) then
                if (m(isp) > 0.0) then  
                   k_rate=0.0  !the species with positive order is the reactant, stop reaction
                   return
                else
                   cb_n  = 1.0 !the species with negative order is the product
                                !let it equal to 1 and make the reaction independent of it
                                !this might not be true, but zero product concentration 
                end if
              end if                                    
              k_rate = k_rate*(cb_n**m(isp)) 
           end do  
                              
        end subroutine calculate_arrhenius_reaction_rate_constant 

   end subroutine calculate_leaching_chemical_model
   
   subroutine calculate_S0_dissolution(di)
     type(darcy_impes_type), intent(inout) :: di
     type(scalar_field), pointer :: o2
     real ::dS0dt, dS0 
     integer :: i, stat
     
     !only dissolve when there are enough dissolved oxygen
     o2 => extract_scalar_field(di%state(2),trim(di%lc%dis%sulf%o2_name), stat=stat)
         if (.not. stat==0) then
         FLAbort('failed to extract the scalar field of liquid  phase oxygen to calculate S0 dissolution')
     end if

     if (di%lc%dis%sulf%bio) then
       !not finished yet
     else
       node_loop: do i=1,di%number_pmesh_node
         !the dissolved S0 from chalcopyrite dissolution
         dS0dt = 2.0*di%lc%dis%chal%dcdt%val(i)*di%lc%dis%sulf%ps
         !only dissolve when there are enough dissolved oxygen
         if ((o2%val(i)+1.5*dS0dt)>=0.0) then
           !calculate the S0 dissolution, dS0/dt  
           !Assumed percentage of S0 generated by Chalcopyrite dissolution is dissolved to SO4
           ! the new calculated dCuFeS2/dt in mole/m^3_heap/s * the percentage of dissolution
           di%lc%dis%sulf%dcdt%val(i) = dS0dt

           !calculate the current S0
           dS0 = -2.0*di%lc%dis%chal%dcdt%val(i)*(1.0-di%lc%dis%sulf%ps)
           di%lc%dis%sulf%S0%val(i) = di%lc%dis%sulf%S0%val(i)+dS0
         else
           dS0 = -2.0*di%lc%dis%chal%dcdt%val(i)
           di%lc%dis%sulf%S0%val(i) = di%lc%dis%sulf%S0%val(i)+dS0
         end if

       end do node_loop
     end if
     
      
   end subroutine calculate_S0_dissolution


   subroutine calculate_jarosite_precipitation(di)
      type(darcy_impes_type), intent(inout) :: di

      type(scalar_field), pointer :: H, Fe3 
      real :: pH, F, rhs, dpre 
      integer :: stat, i
       

      H => extract_scalar_field(di%state(2),trim(di%lc%sol%jaro%H_name), stat=stat)
      if (.not. stat==0) then
        FLAbort('failed to extract the scalar field of H+ to calculate pH')
      end if
      
      Fe3 => extract_scalar_field(di%state(2),trim(di%lc%sol%jaro%Fe3_name), stat=stat)
      if (.not. stat==0) then
        FLAbort('failed to extract the scalar field of Fe3 to calculate jarosite precipitation')
      end if

      do i=1,di%number_pmesh_node         
         !if reactant Fe3 is near zero, stop reaction
         if ((Fe3%val(i)<=0.1) .or. (di%saturation(2)%ptr%val(i)<1.0e-8)) then
           di%lc%sol%jaro%dcdt%val(i)=0.0
         cycle

         end if

         pH=H%val(i)/1000.0
         pH=-DLOG10(pH)
         F=Fe3%val(i)*0.055845  !molar weight of Fe3 is 0.055845 kg/mole         
         F=DLOG10(F)
         rhs=-1.4319*pH+0.8679
         if (F>rhs) then
           dpre=(-2.0e-06)*Fe3%val(i)           
           !change the unit from (mole/m^3 solution/s) to ((mole/m^3 heap/s)
           dpre=di%porosity_pmesh%val(i)*di%saturation(2)%ptr%val(i)*dpre
           di%lc%sol%jaro%js%val(i)=di%lc%sol%jaro%js%val(i)+dpre*(-1.0/3.0)
         else
           dpre=0.0
         end if
         
         di%lc%sol%jaro%dcdt%val(i)=dpre

      end do

      nullify(H)
      nullify(Fe3)
      

   end subroutine calculate_jarosite_precipitation

   subroutine calculate_oxygen_dissolution(di)
        type(darcy_impes_type), intent(inout) :: di

        type(scalar_field), pointer ::og,o2,Tl,og_src,o2_src
        real :: theta1, theta2, T, ft,d_O
        integer :: stat, i
        og => extract_scalar_field(di%state(1),trim(di%lc%sol%oxdi%og_name), stat=stat)
        if (.not. stat==0) then
          FLAbort('failed to extract the scalar field of gas phase oxygen to calculate oxygen dissolution')
        end if        
        !extract the oxygen dissolution source term under og
        og_src  => extract_scalar_field(di%state(1),trim(di%lc%sol%oxdi%og_name)//'_Oxygen_dissolution_gas_phase', stat=stat)
        if (.not. stat==0) then
          FLAbort('failed to extract the scalar field of gas phase source term to calculate oxygen dissolution')
        end if
        o2 => extract_scalar_field(di%state(2),trim(di%lc%sol%oxdi%o2_name), stat=stat)
        if (.not. stat==0) then
          FLAbort('failed to extract the scalar field of liquid  phase oxygen to calculate oxygen dissolution')
        end if
        !extract the oxygen dissolution source term under o2
        o2_src  => extract_scalar_field(di%state(2),trim(di%lc%sol%oxdi%o2_name)//'_Oxygen_dissolution_liquid_phase', stat=stat)
        if (.not. stat==0) then
          FLAbort('failed to extract the scalar field of liquid phase source term to calculate oxygen dissolution')
        end if
        
        Tl =>  di%lc%ht%liquid_temperature
        if (.not. stat==0) then
          FLAbort('failed to extract the scalar field of liquid  temperature to calculate oxygen dissolution')
        end if
        
        !loop over nodes
        ! if only single phase exist, no dissolution
        node_loop: do i=1,di%number_pmesh_node
          if ((di%saturation(1)%ptr%val(i)<=1.0e-8) .or. (di%saturation(2)%ptr%val(i)<=1.0e-8)) then
             di%lc%sol%oxdi%dcdt%val(i)=0.0
             og_src%val(i)=0.0
             o2_src%val(i)=0.0
             cycle
          end if

          !calculate fluid hold-up
          theta1=di%porosity_pmesh%val(i)*di%saturation(1)%ptr%val(i)
          theta2=di%porosity_pmesh%val(i)*di%saturation(2)%ptr%val(i)


          !calculate the equilibrium constant ft, o2=og*ft
          T=Tl%val(i)
          ft=(0.046*(T**2.0)+203.35*T*DLOG(T/298.0)-(299.378+0.092*T)*(T-298)-20.591*(10.0**3.0))/(T*8.3144)
          ft=0.08205746*T*EXP(ft) !0.08205746 is gas constant in the unit of L*atm*K^-1*mol^-1
          
          ! the transfer of oxygen from liquid phase to gas phase in unit of mole/m^3_heap
          d_O=(1.0/(ft/theta1+1.0/theta2))*(o2%val(i)-ft*og%val(i))
          di%lc%sol%oxdi%dcdt%val(i)=d_O
          !add the equilibrium term of oxygen dissolution to gas phase and liquid phase oxygen
          !for gas phase
          og_src%val(i)=d_O/theta1
          og%val(i)=og%val(i)+og_src%val(i)
          !for liquid phase
          o2_src%val(i)=-d_O/theta2
          o2%val(i)=o2%val(i)+o2_src%val(i)

        end do node_loop

        nullify(og)
        nullify(og_src)
        nullify(o2)
        nullify(o2_src)
        nullify(Tl)

   end subroutine calculate_oxygen_dissolution
   


   subroutine calculate_leach_heat_transfer_src(di)
     type(darcy_impes_type), intent(inout) :: di

     !local variables
     integer :: i,n_s,n_l,nsrc_s,nsrc_l,nd,nr,n2_s,n2_l
     real :: Crs,Crl,prts,dTsl,ktp,Hs,Hr

     !---------------for two phase heat transfer--------------------
     !count the number of sources term for solid temperature
     nsrc_s=size(di%lc%ht%two_phase_src_solid)
     nsrc_l=size(di%lc%ht%two_phase_src_liquid)

     node_loop: do i=1,di%number_pmesh_node
       prts=1.0-di%porosity_pmesh%val(i)
       Crs=di%lc%ht%rock_cp%val(i)*di%lc%ht%rock_density%val(i)
       Crl=di%lc%ht%liquid_cp%val(i)*di%density(2)%ptr%val(i)
       dTsl=di%lc%ht%rock_temperature%val(i)-di%lc%ht%liquid_temperature%val(i)
       ktp=di%lc%ht%K_eff_ls%val(i)*dTsl*prts
       
       !loop the liquid temperature source terms
       src_loop_l: do n_l=1,nsrc_l
         
         select case(di%lc%ht%two_phase_src_liquid(n_l)%ptr%name)

           !the solid-liquid heat transfer source
           case('solid_liquid_heat_transfer_liquid_phase')
             di%lc%ht%two_phase_src_liquid(n_l)%ptr%val(i)=ktp/Crl
           case('solution_phase_heat_sources')
             Hr=0.0
             nr=size(di%lc%ht%liquid_sr_src)
             solution_reaction_loop: do n2_l=1,nr
               Hr=Hr+di%lc%ht%liquid_sr_src(n2_l)%sr_src%val(i)*di%lc%ht%liquid_sr_src(n2_l)%Enthalpy                
             end do solution_reaction_loop
             di%lc%ht%two_phase_src_liquid(n_l)%ptr%val(i)=Hr/Crl
           case default
             FLAbort("liquid_phase temperature heat transfer source " // di%lc%ht%two_phase_src_liquid(n_l)%ptr%name // " not found")

         end select    
       end do src_loop_l

       !loop the rock temperature source terms
       src_loop_r: do n_s=1,nsrc_s

         select case(di%lc%ht%two_phase_src_solid(n_s)%ptr%name)
           
           !the solid-liquid heat transfer source
           case('solid_liquid_heat_transfer_rock_phase')
             di%lc%ht%two_phase_src_solid(n_s)%ptr%val(i)=-ktp/Crs
             
           !the heat source from mineral dissolutiom  
           case('mineral_dissolution_heat_sources')
             Hs=0.0
             nd=size(di%lc%ht%rock_md_src)
             dissolution_loop: do n2_s=1,nd
               Hs=Hs+di%lc%ht%rock_md_src(n2_s)%md_src%val(i)*di%lc%ht%rock_md_src(n2_s)%Enthalpy
             end do dissolution_loop
             di%lc%ht%two_phase_src_solid(n_s)%ptr%val(i)=Hs/Crs
           case default
             FLAbort("Solid_phase temperature heat transfer source "// di%lc%ht%two_phase_src_liquid(n_l)%ptr%name // " not found")
         end select

       end do src_loop_r

     end do node_loop

   end subroutine calculate_leach_heat_transfer_src

   subroutine calculate_leach_rock_temperature(di)
     type(darcy_impes_type), intent(inout) :: di

     !local temperature
     integer ::i, nsrc_s,n_s
     real :: prts, dt
     type(scalar_field) :: src
     
     call allocate(src,di%pressure_mesh)
     call zero(src)   
     nsrc_s=size(di%lc%ht%two_phase_src_solid)

     src_loop: do n_s=1, nsrc_s
        call addto(src,di%lc%ht%two_phase_src_solid(n_s)%ptr)
     end do src_loop

     if (di%lc%ht%have_rock_temperature_src) call addto(src,di%lc%ht%rock_temperature_src)
     
     if (di%lcsub%have_leach_subcycle) then
           dt=di%lcsub%sub_dt
     else
           dt=di%dt
     end if
     
     node_loop: do i=1,di%number_pmesh_node

         prts=1.0-di%porosity_pmesh%val(i)

         src%val(i)=src%val(i)*dt/prts

     end do node_loop

     !calculate the new rock temperature
     call addto(di%lc%ht%rock_temperature,src)
     
     call deallocate(src)
   end subroutine calculate_leach_rock_temperature 

   subroutine calculate_leach_heat_transfer_prog_Temperature_src_to_rhs(di)
       type(darcy_impes_type), intent(inout) :: di
       
       !local variables
       integer :: i,n,nsrc
       type(scalar_field) :: src
       !for the liquid phase temperature heat transfer source
       nsrc=size(di%lc%ht%two_phase_src_liquid)
       call allocate(src,di%pressure_mesh)
       call zero(src)
       src_loop: do n=1,nsrc         
        call addto(src,di%lc%ht%two_phase_src_liquid(n)%ptr)
       end do src_loop
       !add leaching heat transfer source terms to the rhs of liquid temperature
       call compute_cv_mass(di%positions, di%cv_mass_pressure_mesh_with_source, src)
       call addto(di%rhs, di%cv_mass_pressure_mesh_with_source)

       call deallocate(src)
       
   end subroutine calculate_leach_heat_transfer_prog_Temperature_src_to_rhs
   
   subroutine darcy_trans_heat_transfer_prog_src_linearization_to_lhs_rhs(di,f)
      type(darcy_impes_type), intent(inout) :: di
      integer, intent(in) :: f

      !local variables
      integer :: i,n,nsrc
      type(scalar_field) :: src_p,src_n,src_linear
      logical :: have_src_p, have_src_n

      have_src_n=.false.
      have_src_p=.false.

      nsrc=size(di%lc%ht%two_phase_src_liquid)
      call allocate(src_p,di%pressure_mesh)
      call allocate(src_n,di%pressure_mesh)
      call zero(src_p)
      call zero(src_n)

      src_loop: do n=1,nsrc
        if (minval(di%lc%ht%two_phase_src_liquid(n)%ptr%val)<0.0) then
          !add to nagtive source
          have_src_n=.true.
          call addto(src_n,di%lc%ht%two_phase_src_liquid(n)%ptr)
        else
          !add to positive source
          have_src_p=.true.
          call addto(src_p,di%lc%ht%two_phase_src_liquid(n)%ptr)
        end if
      end do src_loop

      !add positive leaching heat transfer source terms to the rhs of liquid temperature
      if (have_src_p) then
        call compute_cv_mass(di%positions, di%cv_mass_pressure_mesh_with_source, src_p)
        call addto(di%rhs, di%cv_mass_pressure_mesh_with_source)
      end if

      !linearize negative leaching heat transfer source terms and add to the lhs of liquid temperature
      if (have_src_n) then
         call allocate(src_linear,di%pressure_mesh)
         call zero(src_linear)
         
         node_loop: do i=1,di%number_pmesh_node
           if (di%generic_prog_sfield(f)%sfield%val(i)<=1.0D-15) then
              src_linear%val(i)=0.0
           else
              src_linear%val(i)=src_n%val(i)/di%generic_prog_sfield(f)%sfield%val(i)
           end if
         end do node_loop

         call compute_cv_mass(di%positions, di%cv_mass_pressure_mesh_with_source, src_linear)
         call addto(di%lhs, di%cv_mass_pressure_mesh_with_source)
         call deallocate(src_linear)
      end if

      call deallocate(src_p)
      call deallocate(src_n)

   end subroutine darcy_trans_heat_transfer_prog_src_linearization_to_lhs_rhs

   subroutine add_leach_chemical_prog_src_linearization_to_lhs_rhs(di,f)
      type(darcy_impes_type), intent(inout) :: di
      integer, intent(in) :: f
   
      !local variables
      type(scalar_field) :: leach_src_p,leach_src_n, single_src,leach_src_linear
      integer :: n,p,i
      real :: s_factor !the stoichemistry factor
      character(len=FIELD_NAME_LEN) :: lc_name
      type(scalar_field), pointer :: src => null()
      logical :: have_src_p, have_src_n
      
      have_src_n=.false.
      have_src_p=.false.
      
      call allocate(leach_src_p,di%pressure_mesh)
      call zero(leach_src_p)
      
      call allocate(leach_src_n,di%pressure_mesh)
      call zero(leach_src_n)
      
      call allocate(single_src,di%pressure_mesh)
      
      !for the solution phase reactions
      if (di%generic_prog_sfield(f)%lc_src%have_sol_src) then
        do n=1, size(di%generic_prog_sfield(f)%lc_src%sfield_sol_src)
           lc_name = di%generic_prog_sfield(f)%lc_src%sfield_sol_src(n)%lc_name
           s_factor = di%generic_prog_sfield(f)%lc_src%sfield_sol_src(n)%sto_factor
           call zero(single_src)
           
           select case(trim(lc_name))
             case("Ferrous_Oxidation")
               if (.not. associated(di%lc%sol%feox%dcdt)) &
               FLAbort('Ferrous_Oxidation is turned off in the leaching chemical model, while its source term is turned on under the prognostic scaler field') 
               src => di%lc%sol%feox%dcdt     
           
             case('Jarosite_Precipitation')
               if (.not. associated(di%lc%sol%jaro%dcdt)) &
               FLAbort('Jarosite_Precipitation is turned off in the leaching chemical model, while its source term is turned on under the prognostic scaler field')  
               src => di%lc%sol%jaro%dcdt
           
             case('Oxygen_dissolution_liquid_phase') 
               if (.not. associated(di%lc%sol%oxdi%dcdt)) &
               FLAbort('Oxygen_dissolution is turned off in the leaching chemical model, while its source term is turned on under the prognostic scaler field')
               cycle !calculate elsewhere, in the calculate oxygen dissolution subroutine
      
             case('Oxygen_dissolution_gas_phase')
               if (.not. associated(di%lc%sol%oxdi%dcdt)) &
               FLAbort('Oxygen_dissolution is turned off in the leaching chemical model, while its source term is turned on under the prognostic scaler field')
               cycle !calculate elsewhere, in the calculate oxygen dissolution subroutine
      
             case default
               FLAbort("Leaching chemical algorithm " // trim(lc_name) // " not found")
           end select
           
           call addto(single_src,src,s_factor) !addto the chemical source term with scale of the stoichemistry factor
           
           if (minval(single_src%val)<0.0) then
             !add to nagtive source
             have_src_n=.true.
             call addto(leach_src_n, single_src)
           else
             !add to positive source
             have_src_p=.true.
             call addto(leach_src_p, single_src)
           end if
           
           p=di%generic_prog_sfield(f)%phase
           
           node_loop: do i=1,di%number_pmesh_node
      
             single_src%val(i)=single_src%val(i)/(di%porosity_pmesh%val(i)*di%saturation(p)%ptr%val(i))
      
             di%generic_prog_sfield(f)%lc_src%sfield_sol_src(n)%sfield%val(i)=single_src%val(i) !mole/m^3_solution               
           end do node_loop
      
        end do
      
      end if
      
      !for the mineral dissolution ractions
      if (di%generic_prog_sfield(f)%lc_src%have_dis_src) then
      
        do n=1, size(di%generic_prog_sfield(f)%lc_src%sfield_dis_src)
           lc_name = di%generic_prog_sfield(f)%lc_src%sfield_dis_src(n)%lc_name
           s_factor = di%generic_prog_sfield(f)%lc_src%sfield_dis_src(n)%sto_factor
           call zero(single_src)
        
           select case(trim(lc_name))
              case("CuFeS2_oxidation_aqueous_ferric_sulfate")
                if (.not. associated(di%lc%dis%chal%dcdt)) &
                FLAbort('CuFeS2_oxidation_aqueous_ferric_sulfate is turned off in the leaching chemical model,while its source term is turned on under the prognostic scaler field')
                src => di%lc%dis%chal%dcdt
      
              case('FeS2_oxidation_aqueous_ferric_sulfate')
                if (.not. associated(di%lc%dis%pyri%dcdt)) &
                FLAbort('FeS2_oxidation_aqueous_ferric_sulfate is turned off in the leaching chemical model, while its source term is turned on under the prognostic scaler field')
                src => di%lc%dis%pyri%dcdt
      
              case('S0_dissolution')
                if (.not. associated(di%lc%dis%sulf%dcdt)) &
                FLAbort('S0_dissolution is turned off in the leaching chemical model,while its source term is turned on under the prognostic scaler field')
                src => di%lc%dis%sulf%dcdt
      
              case default
                FLAbort("Leaching chemical algorithm " // trim(lc_name) // " not found")
           end select
        
           call addto(single_src,src,s_factor) !addto the chemical source term with scale of the stoichemistry factor
           
           if (minval(single_src%val)<0.0) then
             !add to nagtive source
             have_src_n=.true.
             call addto(leach_src_n, single_src)
           else
             !add to positive source
             have_src_p=.true.
             call addto(leach_src_p, single_src)
           end if
           
           call set(di%generic_prog_sfield(f)%lc_src%sfield_dis_src(n)%sfield, single_src)
      
        end do
      
      end if    
      
      !Add positive leaching chemical source term to rhs
      if (have_src_p) then
        call compute_cv_mass(di%positions, di%cv_mass_pressure_mesh_with_source, leach_src_p)
        call addto(di%rhs, di%cv_mass_pressure_mesh_with_source)
      end if
      
      !linearize the negative source and add to lhs
      if (have_src_n) then
        call allocate(leach_src_linear,di%pressure_mesh)
        call zero(leach_src_linear)
        
        node_loop2: do i=1,di%number_pmesh_node
           if (di%generic_prog_sfield(f)%sfield%val(i)<=1.0D-15) then
             leach_src_linear%val(i)=0.0
           else
             leach_src_linear%val(i)=leach_src_n%val(i)/di%generic_prog_sfield(f)%sfield%val(i)
           end if
        end do node_loop2
        
        call compute_cv_mass(di%positions, di%cv_mass_pressure_mesh_with_source, leach_src_linear)
        call addto(di%lhs, di%cv_mass_pressure_mesh_with_source)
        call deallocate(leach_src_linear)
      end if
      
      call deallocate(leach_src_p)
      call deallocate(leach_src_n)
      call deallocate(single_src)
      nullify(src)

   end subroutine add_leach_chemical_prog_src_linearization_to_lhs_rhs


   !---------------------some accessory subroutines----------------------------------------

   subroutine cubic_spline_interpolation(a,b,c,d,x_data,x,y)
      real, dimension(:), intent(in) :: a,b,c,d,x_data
      real, intent(in) :: x
      real, intent(out) :: y
      
      integer :: n,ic,jc,pc

      n=size(x_data)

      if (x<=x_data(1)) then
        y=b(1)*(x-x_data(1))+a(1)
      else if (x>x_data(n)) then
        y=b(n)*(x-x_data(n))+a(n)
      else
        ic=0
        jc=n
        do while (jc-ic>1)
         if (mod(jc-ic,2)==0) then
            pc=(jc-ic)/2
         else
            pc=(jc-ic+1)/2
         end if
       
         if (x>x_data(ic+pc)) then
            ic=ic+pc
         else
            jc=ic+pc    
         end if
        end do
        y=a(ic)+b(ic)*(x-x_data(ic))+c(ic)*((x-x_data(ic))**2.0)+d(ic)*((x-x_data(ic))**3.0)
      end if
   end subroutine  cubic_spline_interpolation
   
   subroutine cubic_spline_coefficient(e,dedt_k,spline_coefficient)

      integer :: i
      real, intent(in) :: e(:), dedt_k(:) !the extraction and dextraction_over_k from experiment data
      !the parameters for spline interpolation
      integer :: n,n1,n2
      real, intent(inout) :: spline_coefficient(:,:)!cubic spline coefficients and the last node of data
     
      !parameters pass to thomas algrithm
      real :: dh(size(e)-1), dy(size(e)-1) !the interval between each two nodes
      real :: c(size(e))
      
      n=size(e)
      n1=n-1
      n2=n-2
     
      do i=1, n-1 
        dh(i)=e(i+1)-e(i)
        dy(i)=dedt_k(i+1)-dedt_k(i)
      end do
      
     
      call solve_tridiagonal_matrix(n2,dh,dy,c) 
     
      do i=1, n1
        !the zero order term coefficient
        spline_coefficient(1,i)=dedt_k(i)
        !the 1st order term coefficient
        spline_coefficient(2,i)=dy(i)/dh(i)-c(i)*(dh(i)/2.0)-(dh(i)/6.0)*(c(i+1)-c(i))
        !the 2nd order term coefficient
        spline_coefficient(3,i)=c(i)/2.0
        !the 3rd order term coefficient
        spline_coefficient(4,i)=(c(i+1)-c(i))/(6.0*dh(i))
      end do
      
      spline_coefficient(1,n)=dedt_k(n)
      spline_coefficient(2,n)=(dedt_k(n)-dedt_k(n-1))/(e(n)-e(n-1))
      spline_coefficient(3:4,n)=0.0D0
        
   end subroutine cubic_spline_coefficient

   subroutine solve_tridiagonal_matrix(n2,dh,dy,c)
     !solve tridiagonal matrix by Thomas Algrithm
     integer, intent(in) :: n2
     real, intent(in) :: dh(:), dy(:)
     real, intent(out) :: c(n2+2)

     integer :: j
     real :: x(n2)
     real :: coefficient(4,n2) !coefficient for matrix and vector
                               !a_(i)*x_(i-1)+b_(i)*x_(i)+c_(i)*x(i+1)=d_(i)

     do j=1,n2
        !coefficient a,b,c,d
        coefficient(1,j)=dh(j)
        coefficient(2,j)=2.0*(dh(j)+dh(j+1))
        coefficient(3,j)=dh(j+1)
        coefficient(4,j)=6.0*(dy(j+1)/dh(j+1)-dy(j)/dh(j))
     end do

     do j=1,n2
       if (j == 1) then
         coefficient(3,j)=coefficient(3,j)/coefficient(2,j)
         coefficient(4,j)=coefficient(4,j)/coefficient(2,j)
       else
         coefficient(3,j)=coefficient(3,j)/(coefficient(2,j)-coefficient(3,j-1)*coefficient(1,j))
         coefficient(4,j)=(coefficient(4,j)-coefficient(4,j-1)*coefficient(1,j))/&
                           (coefficient(2,j)-coefficient(3,j-1)*coefficient(1,j))
       end if
     end do

     do j=n2,1,-1
      if (j == n2) then
        x(j)=coefficient(4,j)
      else
        x(j)=(coefficient(4,j)-coefficient(3,j)*x(j+1))
      end if
     end do

     c=[0.0D0,x,0.0D0]

  end subroutine solve_tridiagonal_matrix   

end  module
